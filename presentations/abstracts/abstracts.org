#+TITLE: Abstracts
#+REVEAL_ROOT: ../../
#+REVEAL_THEME: simple
#+REVEAL_HLEVEL: 2
#+REVEAL_DEFAULT_FRAG_STYLE: appear
#+OPTIONS: toc:nil num:nil

* Abstracts
** Draco: Architectural and Operating System Support for System Call Security
  Dimitrios Skarlatos, Qingrong Chen, Jianyan Chen  Tianyin Xu, Josep Torrellas
  
  ~University of Illinois at Urbana-Champaign~
*** Syscall checking
    #+ATTR_REVEAL: :frag (appear)
    - To prevent Untrusted user process from attacking the OS
    - Done at runtime
    - Eg: Seccomp (Linux), Tame, Pledge(OpenBSD), System Call Disable Policy (Windows)
**** Seccomp
    #+ATTR_REVEAL: :frag (appear)
    - Seccomp (Secure Computing) module in Linux
    - Used for isolation and containerization (Docker, Kubernetes, SystemD, etc)
    - Seccomp profiles are BPF programs
    - Checked on every syscall
    - Syscall ID and arguments are checked
**** Overheads of Seccomp
    #+ATTR_REVEAL: :frag (appear)
    - Performs rule based checking
    - "Long list of if statements executed in sequence"
    - High overheads due to checking every syscall
*** Draco
    #+ATTR_REVEAL: :frag (appear)
    - Tries to reduce the overheads of Syscall checking
    - Takes advantage of *Syscall Locality*
      - "20 syscalls account for 86% of all calls"
      - Syscalls are often executed with the same set of arguments
    - Making the common case faster
      - Most syscall invocations are valid
    - Caches recently validated syscall and arguments
    - Avoids rechecking for cache hits
**** Draco Syscall checking
     [[file:./images/draco.png]] 
**** Draco in Software
    #+ATTR_REVEAL: :frag (appear)
    - Syscall Permission Table (SPT)
      - per-process table
      - One bit for each syscall
    - Validated Arguments Table (VAT)
      - OS maintained, per-process table
      - VAT access requires additional memory accesses
**** Draco in Hardware
    #+ATTR_REVEAL: :frag (appear)
    - Syscall Lookaside Buffer (SLB)
      - Caches recently checked syscall and arguments 
    - Syscall Target Buffer (STB)
      - Preloads SLB by prediction
      - VAT access off critical path
*** Evaluations
    #+ATTR_REVEAL: :frag (appear)
    - Full system simulation using Simics
    - Benchmarks
      - Micro : benchmarks from Unixbench, Sysbench, GUPS, etc
      - Macro : HTTPD, NGINX, Redis, Cassandra, etc
    - Results (over insecure baseline)
      - Seccomp : 1.14 and 1.25 for micro and macro
      - Draco in Software: 1.10 and 1.18 for micro and macro
      - Draco in Hardware: less than 1%
** Hardware-based Always-On Heap Memory Safety
   Yonghae Kim^1, Jaekyu Lee^2, Hyesoon Kim^1
   
   Georgia Institute of Technology^1
   Arm Research^2
*** Heap Memory Safety
    - "Illicit use of pointers" - cause of memory safety bugs
    - Heap exploits tries to use Double frees, Use after frees, etc
    - Need to do Pointer Bounds check
      - Storing metadata for each pointer
      - Checking bounds on every pointer dereference
**** Challenges in Pointer Bounds checking
     - Extra instructions overhead
       - Check instructions
       - instructions for metadata propagation
     - Complex metadata addressing
       - Intel MPX uses 2 level hierarchical table
       - Metadata access involves (approx)
         - 3 register to register moves
         - 3 shift operation
         - 2 memory loads
**** ARM Pointer Authentication (PA)
     - ISA extension
     - Generates PAC (PA code) using the pointer and context
     - Signs it with a hardware key
     - Stores PAC in higher unused bits of a pointer
     - Used to check pointer integrity using extra instructions
**** ARM Pointer Authentication (PA) example
     [[file:./images/aos_heap_safety.png]]
*** AOS: Always On Heap memory safety
    1. Pointer signing
       - Uses ARM PA to do selective bounds checking
       - Sign and store metadata for malloc allocated pointers
    2. Bounds checking
       - If the pointer is signed, do a bounds check
       - No need for check instructions
       - Introduce memory check unit to do the check
    3. Metadata management
       - Uses a per-process Hash Bounds table with PAC as the key
**** AOS
     - Stores 8 B metadata for each pointer
     - Hash table access is faster than hierarchical table
     - Detects Use after frees and double frees
       - Frees will remove metadata but not sign
       - Subsequent frees will cause exceptions
       - Subsequent dereferences will cause exceptions
*** Evaluations
    - Using SPEC2006 benchmarks
    - Modified Gem5 simulator
    - Watchdog incurs 19.4 % overheads
    - AOS incurs 8.4 % performance overheads
** GenASM: A High-Performance, Low-Power Approximate String Matching Acceleration Framework for Genome Sequence Analysis 
   [[file:./images/genasm_authors.png]] 
*** Genome Sequence Analysis
**** Genome
     - Nucleic acid sequence (DNA, RNA)
     - Double helix structure with Base pairs (A,T,C,G)
     - Blueprint of life
     - Unique to every individual organism
     - Represented as a string
**** Genome sequence analysis
     - Analysing the features, structure, function and evolution of Genome
     - Applications (Why do GSA?)
       1. Personalized medicine
       2. Evolutionary theory
       3. Forensics
**** Read Mapping
     - Reading the Genome involves
       1. Cut DNA into fragments
       2. GS machines read random fragments called "Reads"
       3. "Reads" mapped to a Reference genome
     - Read mapping
       - Finding possible locations of the read sequence
         in the reference genome
       - Approximate String Matching with Reference genome
**** Approximate String Matching (ASM)
     - Why approximate?
       - Genetic mutations and variations
       - Sequencing errors
     - Why is ASM important?
       - Used in multiple stages of Read mapping
       - Major Bottleneck in GSA
       - Sequencing machines are getting faster => generate reads faster
*** Approximate String Matching (ASM)
**** Formal Definition
     - Input:
       1. Query read sequence Q=[q1 q2 ... qm]
       2. Reference text sequence T=[t1 t2 ... tn] (n>m)
       3. Edit distance threshold E
     - Output:
       - a set of approximate matches of Q in T (allowing for at most E differences)
     - Edits could be
       - insertions
       - deletions
       - substituitions
**** Algorithms
     - Typically implemented as Dynamic programming algorithm
     - Existing DP algorithms are Quadratic in time and space complexity
     - Bitap Algorithm
       * Uses bitwise operations
       * suffers from limitations like
         - Limited by word size
         - Limited compute parallelism
*** GenASM
**** Contributions
     - Modify Bitap algorithm for long reads and parallelism
     - Design a hardware accelerator for Bitap algorithm
     - Evaluate the accelerator in three usecases
       1. Read alignment
       2. Pre alignment filtering
       3. Edit distance calculation
**** Hardware design
     - Distance calculation hardware
       - Implemented as a cyclic systolic array
       - Systolic array
         - Consists of network of processing elements (PEs)
         - Each PE consist of
           1. Processing logic
           2. Flip Flop based storage logic
       - Removes data dependency limitation of Bitap algorithm
**** Evaluations
     - Edit distance b/w two 1Mbp sequences
       - Compared with State-of-the-art Edlib
       - GenASM gives 262-5413x speedup over Edlib
       - Power consumption reduced by 582x
     - Primary Source of improvement: Co-design hardware and software
     - Fast, Area and power efficient accelerator for ASM
** ELFies: Executable Region Checkpoints for Performance Analysis and Simulation
Harish Patil, Alexander Isaev, Wim Heirman

~Intel Corporation~

Alen Sabu, Ali Hajiabadi, Trevor E. Carlson

~National University of Singapore~
*** Workload characterization
    - To understand the behaviour of a system or a program
    - General approaches
      - Performance counters with Native execution
      - Dynamic Binary Instrumentation (Intel Pin)
      - Performance simulation
**** Regions of interest
     - For long running applications, we find *Representative Regions*
     - Detailed analysis performed on these regions
     - How to find representative regions?
       - Phase based Sampling techniques
     - Requirements
       - Need a way to share the ROIs
       - Every subsequent runs should reach the ROIs
       - Need to restrict analysis to ROIs
*** PinPlay
    - Pin based tool for Dynamic Program Slicing
    - Input: Binary + Binary's input + Region information
    - Output: ~Pinballs~ for every region of interest
    - Pinball is used to replay region with ~constrained~ determinism
**** PinPlay
    - Pinball stores
      - Memory image
      - Register values of each thread
      - Syscall injection data
      - Info about shared memory access order
    - Limitations
      - Works only with Pin based simulators
      - Not as fast as native execution
*** ELFies
    - Standalone executables in ELF format
    - Captures the execution of a ROI
    - Advantages
      - Can be used with any characterization tool
      - (Fast) Native execution is possible
      - Easily sharable
    - Main contribution: *pinball2elf*
      - Tool to convert pinball to ELF executables
**** ELFies
    [[file:./images/elfies.png]] 
**** Pinball to ELF conversion
     - Memory pages are mapped to ELF sections
     - Adds startup code to
       - create threads
       - initialize register values
       - jump to beginning of actual code
     - Ignores Syscall injection and Shared memory access order
       - Leads to non determinism
**** Syscall handling
     - Syscalls executed natively
     - Can lead to a different control flow
     - File related syscalls are handled
       - Files are saved
       - Startup code creates file descriptors
**** Graceful exit
     - Uses (PC, Instr. Count) pair to terminate
     - Performance counters to count instructions
     - Instruction count based termination for deviated control flow
**** Evaluations
     - Run SPEC2017 ELFies on Sniper, CoreSim and Gem5 simulators
     - High CPI prediction errors for some benchmarks (20-30%)
     - Instruction count for multi threaded execution increased due to spin loops
     - Main advantage is ~speed~
       - Longest benchmark took few weeks on CoreSim
       - With ELFie native execution, 10 iterations took less than 1 Hour
** Enhancing Atomic Instruction Emulation for Cross-ISA Dynamic Binary Translation
Ziyi Zhao^1, Zhang Jiang^1, Ying Chen^1, Xiaoli Gong^1, Wenwen Wang^2, Pen-Chung Yew^3

~Nankai University~

~University of Georgia~

~University of Minnesota~

*** Problem
**** Dynamic Binary Translation
     - eg: Qemu, Pico
     - Multi threaded, Cross ISA simulation
     - Needs emulation of atomic instructions
**** Atomic instructions
     - Load Linked/Store Conditional (LL/SC)
       - Linked load and store succeeds only if atomic
       - Used in RISC
       - Strong atomicity
     - Compare And Swap (CAS)
       - Stores only if memory location has expected value
       - Used in CISC
       - Suffers from ABA problem
     #+ATTR_REVEAL: :frag (appear)
     - *Need correct and efficient emulation of LL/SC on CAS*
**** Existing approaches
     - Pico-ST
       - Instruments every store instruction to check
       - High runtime overhead
     - Pico-HTM
       - Uses Hardware Transactional Memory
       - Code b/w LL and SC is made a transaction
       - Not portable
     - Pico-CAS
       - Uses CAS instead of SC (slightly incorrect)
       - Strong atomicity not guarenteed
*** Solution
    - Propose two schemes
      1. Hash table based Store Test (HST)
      2. Page Protection based Store Test (PST)
**** Hash table based Store Test (HST)
     - Non blocking hash table
     - Consists of one field, thread id
     - Updated using loads and stores
    [[file:./images/atomic_dbt1.png]] 
**** Page Protection based Store Test (PST)
     - Uses OS page protection
     - Avoids instrumenting every store
     - Incurs context switch cost
    [[file:./images/atomic_dbt2.png]] 
*** Evaluation
    - Implemented in Qemu
    - Using PARSEC benchmarks
    - Emulate ARM (guest) on x86-64 (host)
    - Both HST and PST perform correct emulation
    - HST has gmean speedup of 2.03x over Pico-ST
