#+TITLE: Abstracts
#+REVEAL_ROOT: ../../
#+REVEAL_THEME: simple
#+REVEAL_HLEVEL: 2
#+REVEAL_DEFAULT_FRAG_STYLE: appear
#+OPTIONS: toc:nil num:nil

* Abstracts
** Draco: Architectural and Operating System Support for System Call Security
  Dimitrios Skarlatos, Qingrong Chen, Jianyan Chen  Tianyin Xu, Josep Torrellas
  
  ~University of Illinois at Urbana-Champaign~
*** Syscall checking
    #+ATTR_REVEAL: :frag (appear)
    - To prevent Untrusted user process from attacking the OS
    - Done at runtime
    - Eg: Seccomp (Linux), Tame, Pledge(OpenBSD), System Call Disable Policy (Windows)
**** Seccomp
    #+ATTR_REVEAL: :frag (appear)
    - Seccomp (Secure Computing) module in Linux
    - Used for isolation and containerization (Docker, Kubernetes, SystemD, etc)
    - Seccomp profiles are BPF programs
    - Checked on every syscall
    - Syscall ID and arguments are checked
**** Overheads of Seccomp
    #+ATTR_REVEAL: :frag (appear)
    - Performs rule based checking
    - "Long list of if statements executed in sequence"
    - High overheads due to checking every syscall
*** Draco
    #+ATTR_REVEAL: :frag (appear)
    - Tries to reduce the overheads of Syscall checking
    - Takes advantage of *Syscall Locality*
      - "20 syscalls account for 86% of all calls"
      - Syscalls are often executed with the same set of arguments
    - Making the common case faster
      - Most syscall invocations are valid
    - Caches recently validated syscall and arguments
    - Avoids rechecking for cache hits
**** Draco Syscall checking
     [[file:./images/draco.png]] 
**** Draco in Software
    #+ATTR_REVEAL: :frag (appear)
    - Syscall Permission Table (SPT)
      - per-process table
      - One bit for each syscall
    - Validated Arguments Table (VAT)
      - OS maintained, per-process table
      - VAT access requires additional memory accesses
**** Draco in Hardware
    #+ATTR_REVEAL: :frag (appear)
    - Syscall Lookaside Buffer (SLB)
      - Caches recently checked syscall and arguments 
    - Syscall Target Buffer (STB)
      - Preloads SLB by prediction
      - VAT access off critical path
*** Evaluations
    #+ATTR_REVEAL: :frag (appear)
    - Full system simulation using Simics
    - Benchmarks
      - Micro : benchmarks from Unixbench, Sysbench, GUPS, etc
      - Macro : HTTPD, NGINX, Redis, Cassandra, etc
    - Results (over insecure baseline)
      - Seccomp : 1.14 and 1.25 for micro and macro
      - Draco in Software: 1.10 and 1.18 for micro and macro
      - Draco in Hardware: less than 1%
** Hardware-based Always-On Heap Memory Safety
   Yonghae Kim^1, Jaekyu Lee^2, Hyesoon Kim^1
   
   Georgia Institute of Technology^1
   Arm Research^2
*** Heap Memory Safety
    - "Illicit use of pointers" - cause of memory safety bugs
    - Heap exploits tries to use Double frees, Use after frees, etc
    - Need to do Pointer Bounds check
      - Storing metadata for each pointer
      - Checking bounds on every pointer dereference
**** Challenges in Pointer Bounds checking
     - Extra instructions overhead
       - Check instructions
       - instructions for metadata propagation
     - Complex metadata addressing
       - Intel MPX uses 2 level hierarchical table
       - Metadata access involves (approx)
         - 3 register to register moves
         - 3 shift operation
         - 2 memory loads
**** ARM Pointer Authentication (PA)
     - ISA extension
     - Generates PAC (PA code) using the pointer and context
     - Signs it with a hardware key
     - Stores PAC in higher unused bits of a pointer
     - Used to check pointer integrity using extra instructions
**** ARM Pointer Authentication (PA) example
     [[file:./images/aos_heap_safety.png]]
*** AOS: Always On Heap memory safety
    1. Pointer signing
       - Uses ARM PA to do selective bounds checking
       - Sign and store metadata for malloc allocated pointers
    2. Bounds checking
       - If the pointer is signed, do a bounds check
       - No need for check instructions
       - Introduce memory check unit to do the check
    3. Metadata management
       - Uses a per-process Hash Bounds table with PAC as the key
**** AOS
     - Stores 8 B metadata for each pointer
     - Hash table access is faster than hierarchical table
     - Detects Use after frees and double frees
       - Frees will remove metadata but not sign
       - Subsequent frees will cause exceptions
       - Subsequent dereferences will cause exceptions
*** Evaluations
    - Using SPEC2006 benchmarks
    - Modified Gem5 simulator
    - Watchdog incurs 19.4 % overheads
    - AOS incurs 8.4 % performance overheads
** GenASM: A High-Performance, Low-Power Approximate String Matching Acceleration Framework for Genome Sequence Analysis 
   [[file:./images/genasm_authors.png]] 
*** Genome Sequence Analysis
**** Genome
     - Nucleic acid sequence (DNA, RNA)
     - Double helix structure with Base pairs (A,T,C,G)
     - Blueprint of life
     - Unique to every individual organism
     - Represented as a string
**** Genome sequence analysis
     - Analysing the features, structure, function and evolution of Genome
     - Applications (Why do GSA?)
       1. Personalized medicine
       2. Evolutionary theory
       3. Forensics
**** Read Mapping
     - Reading the Genome involves
       1. Cut DNA into fragments
       2. GS machines read random fragments called "Reads"
       3. "Reads" mapped to a Reference genome
     - Read mapping
       - Finding possible locations of the read sequence
         in the reference genome
       - Approximate String Matching with Reference genome
**** Approximate String Matching (ASM)
     - Why approximate?
       - Genetic mutations and variations
       - Sequencing errors
     - Why is ASM important?
       - Used in multiple stages of Read mapping
       - Major Bottleneck in GSA
       - Sequencing machines are getting faster => generate reads faster
*** Approximate String Matching (ASM)
**** Formal Definition
     - Input:
       1. Query read sequence Q=[q1 q2 ... qm]
       2. Reference text sequence T=[t1 t2 ... tn] (n>m)
       3. Edit distance threshold E
     - Output:
       - a set of approximate matches of Q in T (allowing for at most E differences)
     - Edits could be
       - insertions
       - deletions
       - substituitions
**** Algorithms
     - Typically implemented as Dynamic programming algorithm
     - Existing DP algorithms are Quadratic in time and space complexity
     - Bitap Algorithm
       * Uses bitwise operations
       * suffers from limitations like
         - Limited by word size
         - Limited compute parallelism
*** GenASM
**** Contributions
     - Modify Bitap algorithm for long reads and parallelism
     - Design a hardware accelerator for Bitap algorithm
     - Evaluate the accelerator in three usecases
       1. Read alignment
       2. Pre alignment filtering
       3. Edit distance calculation
**** Hardware design
     - Distance calculation hardware
       - Implemented as a cyclic systolic array
       - Systolic array
         - Consists of network of processing elements (PEs)
         - Each PE consist of
           1. Processing logic
           2. Flip Flop based storage logic
       - Removes data dependency limitation of Bitap algorithm
**** Evaluations
     - Edit distance b/w two 1Mbp sequences
       - Compared with State-of-the-art Edlib
       - GenASM gives 262-5413x speedup over Edlib
       - Power consumption reduced by 582x
     - Primary Source of improvement: Co-design hardware and software
     - Fast, Area and power efficient accelerator for ASM
